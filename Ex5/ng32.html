
<head>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/sunburst-chart"></script>

  <style>body { margin: 0 }</style>

</head>
<body>
  <div id="chart"></div>

  <script>
    const data = 
{ name: "all", calls: 1, size: 0, value: 173.2, min: 173.2, max: 173.2, avg: 173.2, children: [{ name: "ngcore::ParallelFor<int,ngcore::EnterTaskManager()::{lambda(int)#1}>(ngcore::T_Range<int>,ngcore::EnterTaskManager()::{lambda(int)#1},int,ngcore::TotalCosts)::{lambda(ngcore::TaskInfo&)#1}", calls: 1, size: 0.001426, value: 0.001426, min: 0.001426, max: 0.001426, avg: 0.001426} , { name: "NewtonSolver.Solve", calls: 1, size: 1.334, value: 170.1, min: 170.1, max: 170.1, avg: 170.1, children: [{ name: "Assemble Linearization", calls: 2, size: 0.04367, value: 160.5, min: 42.66, max: 117.8, avg: 80.25, children: [{ name: "Assemble Linearization - SpecialElements", calls: 2, size: 0.001093, value: 0.00407, min: 0.002023, max: 0.002047, avg: 0.002035, children: [{ name: "ngcore::ParallelForRange<unsigned long,ngcomp::S_BilinearForm<double>::AssembleLinearization(ngla::BaseVector const&,ngcore::LocalHeap&,bool)::{lambda(ngcore::T_Range<unsigned long>)#3}>(ngcore::T_Range<unsigned long>,ngcomp::S_BilinearForm<double>::AssembleLinearization(ngla::BaseVector const&,ngcore::LocalHeap&,bool)::{lambda(ngcore::T_Range<unsigned long>)#3},int,ngcore::TotalCosts)::{lambda(ngcore::TaskInfo&)#1}", calls: 2, size: 0.002977, value: 0.002977, min: 0.001432, max: 0.001546, avg: 0.001489}]} , { name: "Assemble Linearization - volume", calls: 3, size: 0.2864, value: 158, min: 0.2754, max: 116.3, avg: 52.68, children: [{ name: "ngcomp::IterateElements(ngcomp::FESpace const&,ngfem::VorB,ngcore::LocalHeap&,std::function<void(ngcomp::FESpace::Element,ngcore::LocalHeap&)>const&)::{lambda(ngcore::TaskInfo const&)#1}", calls: 86, size: 157.8, value: 157.8, min: 0.01885, max: 10.4, avg: 1.834}]} , { name: "S_BaseVector::SetScalar", calls: 2, size: 0.003626, value: 2.407, min: 1.176, max: 1.231, avg: 1.203, children: [{ name: "ngcore::ParallelForRange<unsigned long,ngla::S_BaseVector<double>::SetScalar(double)::{lambda(ngcore::T_Range<unsigned long>)#1}>(ngcore::T_Range<unsigned long>,ngla::S_BaseVector<double>::SetScalar(double)::{lambda(ngcore::T_Range<unsigned long>)#1},int,ngcore::TotalCosts)::{lambda(ngcore::TaskInfo&)#1}", calls: 2, size: 2.403, value: 2.403, min: 1.174, max: 1.228, avg: 1.201}]}]} , { name: "Apply Matrix", calls: 2, size: 0.003738, value: 8.264, min: 2.756, max: 5.508, avg: 4.132, children: [{ name: "Apply Matrix - DG", calls: 2, size: 8.708e-05, value: 8.708e-05, min: 2.109e-05, max: 6.599e-05, avg: 4.354e-05} , { name: "Apply Matrix - boundary", calls: 1, size: 0.006813, value: 0.0687, min: 0.0687, max: 0.0687, avg: 0.0687, children: [{ name: "ngcomp::IterateElements(ngcomp::FESpace const&,ngfem::VorB,ngcore::LocalHeap&,std::function<void(ngcomp::FESpace::Element,ngcore::LocalHeap&)>const&)::{lambda(ngcore::TaskInfo const&)#1}", calls: 10, size: 0.06189, value: 0.06189, min: 0.004006, max: 0.01239, avg: 0.006189}]} , { name: "Apply Matrix - volume", calls: 2, size: 0.07156, value: 8.192, min: 2.755, max: 5.437, avg: 4.096, children: [{ name: "ngcomp::IterateElements(ngcomp::FESpace const&,ngfem::VorB,ngcore::LocalHeap&,std::function<void(ngcomp::FESpace::Element,ngcore::LocalHeap&)>const&)::{lambda(ngcore::TaskInfo const&)#1}", calls: 76, size: 8.12, value: 8.12, min: 0.03772, max: 0.9789, avg: 0.1068}]}]} , { name: "S_BaseVector::SetScalar", calls: 2, size: 0.00156, value: 0.01249, min: 0.0052, max: 0.007291, avg: 0.006246, children: [{ name: "ngcore::ParallelForRange<unsigned long,ngla::S_BaseVector<double>::SetScalar(double)::{lambda(ngcore::T_Range<unsigned long>)#1}>(ngcore::T_Range<unsigned long>,ngla::S_BaseVector<double>::SetScalar(double)::{lambda(ngcore::T_Range<unsigned long>)#1},int,ngcore::TotalCosts)::{lambda(ngcore::TaskInfo&)#1}", calls: 2, size: 0.01093, value: 0.01093, min: 0.004855, max: 0.006076, avg: 0.005465}]}]}]};

const chart_type = 'time';

    const color = d3.scaleOrdinal(d3.schemePaired);

    let getTime = (t) =>
    {
       if(t>=1000)  return (t/1000).toPrecision(4) + '  s';
       if(t>=0.1)   return t.toPrecision(4) + ' ms';
       if(t>=1e-4)  return (t*1e3).toPrecision(4) + ' us';

       return (t/1e6).toPrecision(4) + ' ns';
    };

    const KB_ = 1024;
    const MB_ = KB_*1024;
    const GB_ = MB_*1024;
    let getMemory = (m) =>
    {
       if(m>=GB_)  return (m/GB_).toPrecision(4) + ' GB';
       if(m>=MB_)  return (m/MB_).toPrecision(4) + ' MB';
       if(m>=KB_)  return (m/KB_).toPrecision(4) + ' KB';
       return m.toPrecision(4) + ' B';
    };

    Sunburst()
      .data(data)
      .size('size')
      .color(d => color(d.name))
      .tooltipTitle((d, node) => { return node.parent ? node.parent.data.name + " &rarr; " + d.name : d.name; })
      .tooltipContent((d, node) => {
        if(chart_type=="memory")
        {
          return `Total Memory: <i>${getMemory(d.value)}</i> <br>`
               + `Memory: <i>${getMemory(d.size)}</i>`
        }
        else
        {
          return `Time: <i>${getTime(d.value)}</i> <br>`
               + `calls: <i>${d.calls}</i> <br>`
               + `min: <i>${getTime(d.min)}</i> <br>`
               + `max: <i>${getTime(d.max)}</i> <br>`
               + `avg: <i>${getTime(d.avg)}</i>`
        }
      })
      (document.getElementById('chart'));

      // Line breaks in tooltip
      var all = document.getElementsByClassName('sunbirst-tooltip');
      for (var i = 0; i < all.length; i++) {
          all[i].white_space = "";
      }
  </script>
</body>

